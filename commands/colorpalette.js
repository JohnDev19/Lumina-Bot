const sharp = require('sharp');
const Color = require('color');

class ColorPaletteGenerator {
  constructor() {
    this.paletteSize = 5;
    this.width = 1000;
    this.height = 500;
  }

  validateColorInput(input) {
    try {
      return input ? Color(input) : null;
    } catch (error) {
      return null;
    }
  }

  generateColorPalette(baseColor = null) {
    if (baseColor) {
      return [
        baseColor,
        baseColor.lighten(0.2),
        baseColor.darken(0.2),
        baseColor.rotate(30),
        baseColor.rotate(-30)
      ];
    }

    return Array.from({ length: this.paletteSize }, () => 
      Color.rgb([
        Math.floor(Math.random() * 256),
        Math.floor(Math.random() * 256),
        Math.floor(Math.random() * 256)
      ])
    );
  }

  getColorFormats(color) {
    return {
      hex: color.hex(),
      hsl: color.hsl().string(),
      rgb: color.rgb().string(),
      rgba: color.alpha(1).rgb().string()
    };
  }

  async createPaletteImage(colors) {
    const colorBlockWidth = this.width / colors.length;

    const colorBlocks = colors.map((color, index) => {
      const hexColor = color.hex();
      const textColor = this.getContrastYIQ(hexColor);

      return {
        input: Buffer.from(`
          <svg xmlns="http://www.w3.org/2000/svg" width="${colorBlockWidth}" height="${this.height}">
            <rect width="${colorBlockWidth}" height="${this.height}" fill="${hexColor}"/>
            <text x="50%" y="50%" text-anchor="middle" font-family="Arial" font-size="30" font-weight="bold" fill="${textColor}">
              ${hexColor.toUpperCase()}
            </text>
          </svg>
        `),
        left: index * colorBlockWidth,
        top: 0
      };
    });

    const watermarkSvg = Buffer.from(`
      <svg xmlns="http://www.w3.org/2000/svg" width="${this.width}" height="${this.height}">
        <text x="50%" y="${this.height - 50}" text-anchor="middle" font-family="Arial" font-size="24" fill="rgba(255,255,255,0.7)" font-weight="bold">
          Generated by Lumina
        </text>
      </svg>
    `);

    const paletteImage = await sharp({
      create: {
        width: this.width,
        height: this.height,
        channels: 4,
        background: { r: 30, g: 30, b: 30, alpha: 1 }
      }
    })
    .composite([
      ...colorBlocks,
      {
        input: watermarkSvg,
        top: 0,
        left: 0,
        blend: 'over'
      }
    ])
    .png()
    .toBuffer();

    return paletteImage;
  }

  getContrastYIQ(hexcolor) {
    const r = parseInt(hexcolor.slice(1, 3), 16);
    const g = parseInt(hexcolor.slice(3, 5), 16);
    const b = parseInt(hexcolor.slice(5, 7), 16);
    const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
    return (yiq >= 128) ? 'black' : 'white';
  }

  getLuminaErrorMessage(errorType) {
    const errorMessages = {
      invalidColor: [
        "Oops! ü§ñ I'm having trouble understanding that color. Could you try again with a valid color like 'red' or '#FF5733'?",
        "Hey there! üåà I'm a bit confused by the color you provided. Mind giving me a clear color name or hex code?",
        "Hmm... üßê That doesn't look like a color I recognize. Can you help me out with a standard color name or hex code?"
      ],
      generationFailed: [
        "Uh-oh! üòÖ My color magic seems to have short-circuited. Let's try that again!",
        "Whoops! üîß My color generator is feeling a bit shy today. Mind giving it another shot?",
        "Looks like my color crystals are a bit cloudy. Care to help me clear them up?"
      ],
      tooManyArguments: [
        "Whoa there! üé® I only need one color to work my magic. Try using just one color value!",
        "Hey friend! üåà Let's keep it simple - just give me one color to work with.",
        "One color is all I need! ÔøΩpalette Try again with just a single color value."
      ]
    };

    const messages = errorMessages[errorType];
    return messages[Math.floor(Math.random() * messages.length)];
  }
}

module.exports = {
  name: 'colorpalette',
  description: 'Generate beautiful color palettes with multiple formats and visual representation',
  
  async execute(bot, msg, args) {
    const chatId = msg.chat.id;
    const generator = new ColorPaletteGenerator();

    if (args.length === 0) {
      const usageMessage = `
üé® *Color Palette Generator Usage Guide*

Generate beautiful color palettes with these commands:

1Ô∏è‚É£ *Random Palette*
Command: \`/colorpalette\`
Description: Generates a random color palette

2Ô∏è‚É£ *Based on Color*
Command: \`/colorpalette <color>\`
Example: \`/colorpalette #FF5733\` or \`/colorpalette red\`

3Ô∏è‚É£ *Special Palettes*
‚Ä¢ \`/colorpalette complementary <color>\`
‚Ä¢ \`/colorpalette analogous <color>\`
‚Ä¢ \`/colorpalette triadic <color>\`

*Supported Color Formats:*
‚Ä¢ Hex codes (#FF5733)
‚Ä¢ Color names (red, blue, green)
‚Ä¢ RGB (rgb(255, 87, 51))
‚Ä¢ HSL (hsl(360, 100%, 50%))

*Note:* All palettes include 5 colors with their HEX, RGB, RGBA, and HSL values.
`;
      return bot.sendMessage(chatId, usageMessage, { parse_mode: 'Markdown' });
    }

    await bot.sendChatAction(chatId, 'generating');

    if (args.length > 2) {
      const errorMessage = generator.getLuminaErrorMessage('tooManyArguments');
      return bot.sendMessage(chatId, errorMessage);
    }

    try {
      let colors;
      let caption;

      if (args.length === 2) {
        const type = args[0].toLowerCase();
        const baseColor = generator.validateColorInput(args[1]);

        if (!baseColor) {
          const errorMessage = generator.getLuminaErrorMessage('invalidColor');
          return bot.sendMessage(chatId, errorMessage);
        }

        switch (type) {
          case 'complementary':
            colors = [
              baseColor,
              baseColor.rotate(180),
              baseColor.lighten(0.2),
              baseColor.rotate(180).lighten(0.2),
              baseColor.darken(0.2)
            ];
            caption = 'üåà Complementary Color Palette';
            break;
          case 'analogous':
            colors = [
              baseColor,
              baseColor.rotate(30),
              baseColor.rotate(-30),
              baseColor.lighten(0.2),
              baseColor.darken(0.2)
            ];
            caption = 'üåà Analogous Color Palette';
            break;
          case 'triadic':
            colors = [
              baseColor,
              baseColor.rotate(120),
              baseColor.rotate(240),
              baseColor.lighten(0.2),
              baseColor.darken(0.2)
            ];
            caption = 'üåà Triadic Color Palette';
            break;
          default:
            return bot.sendMessage(chatId, 'Invalid palette type. Use: complementary, analogous, or triadic.');
        }
      } else {
        const baseColor = generator.validateColorInput(args[0]);
        if (baseColor) {
          colors = generator.generateColorPalette(baseColor);
          caption = 'üåà Custom Color Palette';
        } else {
          colors = generator.generateColorPalette();
          caption = 'üåà Random Color Palette';
        }
      }

      const colorFormats = colors.map(color => generator.getColorFormats(color));
      const formattedResponse = colorFormats.map((color, index) => 
        `üé® Color ${index + 1}:\n` +
        `HEX: <code>${color.hex}</code>\n` +
        `HSL: <code>${color.hsl}</code>\n` +
        `RGB: <code>${color.rgb}</code>\n` +
        `RGBA: <code>${color.rgba}</code>\n`
      ).join('\n');

      const paletteImage = await generator.createPaletteImage(colors);

      await bot.sendPhoto(chatId, paletteImage, {
        caption: `${caption}:\n\n${formattedResponse}`,
        parse_mode: 'HTML'
      });

    } catch (error) {
      console.error('Color Palette Generation Error:', error);
      const errorMessage = generator.getLuminaErrorMessage('generationFailed');
      await bot.sendMessage(chatId, errorMessage);
    }
  }
};
