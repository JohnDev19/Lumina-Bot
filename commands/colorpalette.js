const sharp = require('sharp');
const Color = require('color');

class ColorPaletteGenerator {
  constructor() {
    this.paletteSize = 5;
  }

  // Generate Random Color
  generateRandomColor() {
    return Color.rgb([
      Math.floor(Math.random() * 256),
      Math.floor(Math.random() * 256),
      Math.floor(Math.random() * 256)
    ]);
  }

  // Generate Color Palette
  generateColorPalette() {
    return Array.from({ length: this.paletteSize }, () => this.generateRandomColor());
  }

  // Convert Color Formats
  getColorFormats(color) {
    return {
      hex: color.hex(),
      hsl: color.hsl().string(),
      rgb: color.rgb().string(),
      rgba: color.alpha(1).rgb().string()
    };
  }

  // Create Palette Image
  async createPaletteImage(colors) {
    const width = 800;
    const height = 400;
    const colorBlockWidth = width / colors.length;

    // Create color blocks
    const colorBlocks = colors.map((color, index) => ({
      input: Buffer.from(`<svg xmlns="http://www.w3.org/2000/svg" width="${colorBlockWidth}" height="${height}">
        <rect width="${colorBlockWidth}" height="${height}" fill="${color.hex()}"/>
      </svg>`),
      left: index * colorBlockWidth,
      top: 0
    }));

    // Add text overlay
    const textSvg = Buffer.from(`
      <svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}">
        <text 
          x="50%" 
          y="90%" 
          text-anchor="middle" 
          font-family="Arial" 
          font-size="24" 
          fill="white" 
          opacity="0.7">
          Generated by Lumina
        </text>
      </svg>
    `);

    // Composite image
    const paletteImage = await sharp({
      create: {
        width: width,
        height: height,
        channels: 4,
        background: { r: 255, g: 255, b: 255, alpha: 0 }
      }
    })
    .composite([
      ...colorBlocks,
      {
        input: textSvg,
        top: 0,
        left: 0,
        blend: 'over'
      }
    ])
    .png()
    .toBuffer();

    return paletteImage;
  }
}

module.exports = {
  name: 'colorpalette',
  description: 'Generate a sophisticated color palette with multiple formats',
  
  async execute(bot, msg, args) {
    const chatId = msg.chat.id;
    const generator = new ColorPaletteGenerator();

    try {
      // Generate Color Palette
      const colors = generator.generateColorPalette();

      // Prepare Color Formats
      const colorFormats = colors.map(color => generator.getColorFormats(color));

      // Create Formatted Response
      const formattedResponse = colorFormats.map((color, index) => 
        `üé® Color ${index + 1}:\n` +
        `HEX: ${color.hex}\n` +
        `HSL: ${color.hsl}\n` +
        `RGB: ${color.rgb}\n` +
        `RGBA: ${color.rgba}\n`
      ).join('\n');

      // Generate Palette Image
      const paletteImage = await generator.createPaletteImage(colors);

      // Send Response with Image
      await bot.sendPhoto(chatId, paletteImage, {
        caption: `üåà Generated Color Palette:\n\n${formattedResponse}`,
        parse_mode: 'Markdown'
      });

    } catch (error) {
      console.error('Color Palette Generation Error:', error);
      await bot.sendMessage(chatId, '‚ùå Failed to generate color palette. Please try again.');
    }
  }
};
